<!DOCTYPE html>
<html lang="zh">

<head>
    <title>Generate Java POJO File From Json</title>
    <link rel="icon" type="image/x-icon" class="js-site-favicon" href="https://github.githubassets.com/favicon.ico">
    <link rel="stylesheet" href="https://jiehuifang.github.io/webTools.css">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>

<body>
    <div id="app">
        <p>Generate Java POJO File From Json</p>
        <p>
            <a href="https://jiehuifang.github.io/">back to the contents</a>
        </p>
        <br>
        <div>
            <textarea id="json_schema" rows="50" cols="100" placeholder="json schema area"></textarea>
            <textarea id="java_schema" rows="50" cols="100" placeholder="java schema area" readonly></textarea>
        </div>
        <br>
        <div>
            <!-- button -->
            <button onclick="format()">format</button>
            <button onclick="generate()">generate</button>
            <button onclick="clean()">clean</button>
        </div>
    </div>
</body>
<script>
    // Java Access Type
    const private_access_type = "private";

    // Java Type
    const integer_type = "Integer";
    const double_type = "Double";
    const boolean_type = "Boolean";
    const string_type = "String";
    const object_type = "Object";

    // have specify handle type
    const list_type = "List";
    const map_type = "Map";
    const dto_type = "Dto";

    // Java Class Constant Area
    const class_type = "public class %0% {\n\n";
    const java_line_end_symbol = ";\n\n";
    const java_class_file_end_symbol = "}";
    const java_tab_symbol = "    ";
    const java_dto_class_suffix = "Dto";
    const java_map_class_suffix = "Map";
    const single_class_symbol = "\n\n";
    const between_word_symbol = " ";
    const no_java_field_regexp = /^(([a-z]+[0-9]+)|([0-9]+[a-z]+))[a-z0-9]*$/i;

    //global var
    let handle_stack;
    let generate_compile_record;

    // clean record
    function clean() {
        document.getElementById("java_schema").innerHTML = '';
        document.getElementById("json_schema").value = '';
    }

    // format json
    function format() {
        try {
            let source_text = document.getElementById("json_schema").value;
            document.getElementById("json_schema").value = JSON.stringify(JSON.parse(source_text), null, 4);
        } catch (e) {
            console.log(e);
            alert("illegal json schema");
        }
    }

    // replace placeholder function
    String.prototype.format = function() {
        if (arguments.length == 0) return this;
        let param = arguments[0];
        let s = this;
        if (typeof(param) == 'object') {
            for (let k in param)
                s = s.replace(new RegExp("\\%" + k + "\\%", "g"), param[k]);
        } else {
            for (let i = 0; i < arguments.length; i++)
                s = s.replace(new RegExp("\\%" + i + "\\%", "g"), arguments[i]);
        }
        return s;
    }

    // generate function
    function generate() {
        try {
            let json_schema_text = document.getElementById("json_schema").value;
            let json_schema_obj = JSON.parse(json_schema_text);
            handle_stack = [];
            generate_compile_record = {};
            handle_stack.push({
                "name": "Root",
                "obj": json_schema_obj
            });
            let java_schema_text = "";
            let temp;
            while (handle_stack.length > 0) {
                temp = packageJavaObject(handle_stack.pop());
                if (temp != null) {
                    java_schema_text = java_schema_text + temp + single_class_symbol;
                }
            }
            document.getElementById("java_schema").innerHTML = java_schema_text;
        } catch (e) {
            console.log(e);
            alert("illegal json schema");
        }
    }

    // is collect result
    function isCollectResult(className) {
        if (isMapName(className)) {
            return false;
        }
        if (generate_compile_record[className] != undefined) {
            return false;
        } else {
            generate_compile_record[className] = 1;
            return true
        }
    }

    // package type info
    function packageTypeInfo(className, field, fieldType) {
        if (fieldType == list_type) {
            return list_type + "<%" + fixHandleTypeName(className, field, fieldType) + "%>";
        } else if (fieldType == map_type) {
            // json key must be string
            return map_type + "<String, %" + fixHandleTypeName(className, field, fieldType) + "%>";
        } else if (fieldType == dto_type) {
            return fixHandleTypeName(className, field, fieldType);
        } else {
            return fieldType;
        }
    }

    // get java type info
    function getJavaTypeInfo(obj, field) {
        if (typeof(obj[field]) == 'string') {
            return string_type;
        } else if (typeof(obj[field]) == 'boolean') {
            return boolean_type;
        } else if (typeof(obj[field]) == 'number') {
            if (obj[field].toString().includes(".")) {
                return double_type;
            } else {
                return integer_type;
            }
        } else if (obj[field] instanceof Array) {
            return list_type;
        } else {
            // js object
            return isDtoOrMapOrObj(obj, field);
        }
    }

    // is dto or map or object
    function isDtoOrMapOrObj(obj, field) {
        let isMap = false;
        if (obj[field] == null || Object.keys(obj[field]).length == 0) {
            return object_type;
        } else {
            for (innerField in obj[field]) {
                if (!isNaN(Number(innerField))) {
                    isMap = true;
                    break;
                }
                if (no_java_field_regexp.test(innerField)) {
                    isMap = true;
                    break;
                }
            }
            return isMap ? map_type : dto_type;
        }
    }

    // is map name now
    function isMapName(className) {
        return className.endsWith(java_map_class_suffix);
    }

    // fix handle type name
    function fixHandleTypeName(className, field, fieldType) {
        let prefix = field.substring(0, 1).toUpperCase() + field.substring(1);
        if (fieldType == map_type) {
            return prefix + java_map_class_suffix;
        } else if (fieldType == dto_type && isMapName(className)) {
            return className + java_dto_class_suffix;
        } else if (fieldType == dto_type && !isMapName(className)) {
            return prefix + java_dto_class_suffix;
        } else if (fieldType == list_type) {
            return prefix + java_dto_class_suffix;
        }
        // illegal call function default return type
        return fieldType;
    }

    // push handle obj
    function pushHandle(className, obj, field, fieldType) {
        let handle = {};
        if (fieldType == map_type || fieldType == dto_type) {
            handle["name"] = fixHandleTypeName(className, field, fieldType)
            handle["obj"] = obj[field];
        } else if (fieldType == list_type && obj[field].length > 0) {
            // default list item type is dto not map
            handle["name"] = fixHandleTypeName(className, field, fieldType);
            // default only handle frist element
            handle["obj"] = obj[field][0];
        }
        if (Object.keys(handle).length > 0) {
            handle_stack.push(handle);
        }
    }

    // package java object
    function packageJavaObject({
        name,
        obj
    }) {
        let result = class_type.format(name);
        let typeTemp;
        for (let field in obj) {
            typeTemp = getJavaTypeInfo(obj, field);
            result = result + java_tab_symbol + private_access_type + between_word_symbol + packageTypeInfo(name, field, typeTemp) + between_word_symbol + field + java_line_end_symbol;
            pushHandle(name, obj, field, typeTemp);
        }
        return isCollectResult(name) ? result + java_class_file_end_symbol : null;
    }
</script>

</html>